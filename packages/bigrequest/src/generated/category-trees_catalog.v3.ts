// @ts-nocheck
/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */


/** WithRequired type helpers */
type WithRequired<T, K extends keyof T> = T & { [P in K]-?: T[P] };

export interface paths {
  "/catalog/trees/categories": {
    /**
     * Get All Categories
     * @description Returns a list of categories.
     *
     * To get a specific category in a tree, provide a category ID.
     */
    get: operations["getAllCategories"];
    /**
     * Update Categories
     * @description Updates existing categories.
     *
     *  To update a specific category in a tree, provide a category id.
     */
    put: operations["updateCategories"];
    /**
     * Create Categories
     * @description Creates new categories.
     *
     * Creating a category requires:
     *  - `name`
     *  - `url`
     *  - `tree_id` or `parent_id`
     */
    post: operations["createCategories"];
    /**
     * Delete Categories
     * @description Deletes categories.
     *
     * To delete a specific category in a tree, provide a category ID.
     */
    delete: operations["deleteTreeCategories"];
    parameters: {
      header: {
        Accept: components["parameters"]["Accept"];
      };
    };
  };
  "/catalog/trees": {
    /**
     * Get All Category Trees
     * @description Returns a list of *Category Trees*.
     */
    get: operations["GetCategoryTrees"];
    /**
     * Upsert Category Trees
     * @description Upserts *Category Trees*.
     *
     * This single endpoint updates and creates category trees. If a tree object contains an ID, it is processed as an update operation using that ID. If you do not provide an ID, a new tree is created. The category tree `name` field is required to create trees, but is not required on the update.
     *
     * **Usage Notes**
     * * `channel_id` is required to create a *Category Tree*. You can assign one `channel_id` to one category tree.
     */
    put: operations["UpsertCategoryTrees"];
    /**
     * Delete Category Trees
     * @description Deletes *Category Trees*. A filter must be supplied with the endpoint.
     */
    delete: operations["DeleteCategoryTrees"];
    parameters: {
      header: {
        Accept: components["parameters"]["Accept"];
      };
    };
  };
  "/catalog/trees/{tree_id}/categories": {
    /**
     * Get a Category Tree
     * @description Returns a *Category Tree*.
     */
    get: operations["GetCategoryTreeByTreeId"];
    parameters: {
      header: {
        Accept: components["parameters"]["Accept"];
      };
      path: {
        tree_id: string;
      };
    };
  };
}

export type webhooks = Record<string, never>;

export interface components {
  schemas: {
    /**
     * Response meta
     * @description Response metadata.
     */
    metaEmpty_Full: {
      [key: string]: unknown;
    };
    /**
     * DetailedErrors
     * @description Each key-value pair describes a failure or partial success case.
     */
    DetailedErrors: {
      [key: string]: unknown;
    };
    /** Create Categories */
    CreateCategories: (components["schemas"]["TreeIdCreateData"] & components["schemas"]["ParentIdCreateData"] & components["schemas"]["CategoryDataPOST"])[];
    UpdateCategories: (components["schemas"]["TreeIdUpdateData"] & components["schemas"]["CategoryIdUpdateData"] & components["schemas"]["CategoryUuidData"] & components["schemas"]["ParentIdUpdateData"] & components["schemas"]["CategoryDataPUT"])[];
    /** Category */
    Category: components["schemas"]["id"] & components["schemas"]["parent_id"] & components["schemas"]["name"] & components["schemas"]["description"] & components["schemas"]["views"] & components["schemas"]["sort_order"] & components["schemas"]["page_title"] & components["schemas"]["meta_keywords"] & components["schemas"]["meta_description"] & components["schemas"]["layout_file"] & components["schemas"]["image_url"] & components["schemas"]["is_visible"] & components["schemas"]["search_keywords"] & components["schemas"]["default_product_sort"] & {
      custom_url?: components["schemas"]["Url"];
    };
    /** category_uuid */
    CategoryUuidData: {
      /** Format: uuid */
      category_uuid?: string;
    };
    CategoryIdUpdateData: {
      category_id: number;
    };
    ParentIdCreateData: {
      parent_id: number;
    };
    TreeIdCreateData: {
      tree_id: number;
    };
    ParentIdUpdateData: {
      parent_id?: number;
    };
    TreeIdUpdateData: {
      tree_id?: number;
    };
    CategoryData: {
      name?: string;
      description?: string;
      views?: number;
      sort_order?: number;
      page_title?: string;
      search_keywords?: string;
      meta_keywords?: string[];
      meta_description?: string;
      layout_file?: string;
      is_visible?: boolean;
      image_url?: string;
      custom_url?: components["schemas"]["Url"];
    };
    CategoryDataPUT: components["schemas"]["CategoryData"] & components["schemas"]["default_product_sort"];
    CategoryDataPOST: WithRequired<components["schemas"]["CategoryData"] & components["schemas"]["default_product_sort"], "name" | "url">;
    Url: {
      url?: string;
      is_customized?: boolean;
    };
    MetaPagination: {
      pagination?: {
        /** @example 246 */
        total?: number;
        /** @example 5 */
        count?: number;
        /** @example 5 */
        per_page?: number;
        /** @example 1 */
        current_page?: number;
        /** @example 50 */
        total_pages?: number;
        links?: {
          /** @example ?limit=5&page=1 */
          previous?: string;
          /** @example ?limit=5&page=2 */
          current?: string;
          /** @example ?limit=5&page=3 */
          next?: string;
        };
      };
    };
    ErrorRequest: {
      errors?: components["schemas"]["ErrorBasic"][];
    };
    ErrorBasic: {
      /** @description The HTTP status code. */
      status?: number;
      /** @description The error title describing the particular error. */
      title?: string;
      type?: string;
    };
    ErrorAdditional: {
      errors?: components["schemas"]["DetailedErrors"];
    };
    MetaError: components["schemas"]["ErrorBasic"] & components["schemas"]["ErrorAdditional"];
    MetaData: {
      total?: number;
      success?: number;
      failed?: number;
    };
    SuccessNoContentResponse: {
      meta?: components["schemas"]["MetaData"];
    };
    PartialSuccessNoContentResponse: {
      errors?: components["schemas"]["MetaError"];
      meta?: components["schemas"]["MetaData"];
    };
    PartialSuccessResponse: {
      data?: components["schemas"]["Category"][];
      meta?: components["schemas"]["MetaData"];
    };
    SuccessResponse: {
      data?: components["schemas"]["Category"][];
      errors?: components["schemas"]["MetaError"];
      meta?: components["schemas"]["MetaData"];
    };
    ErrorResponse: {
      errors?: components["schemas"]["MetaError"];
      meta?: components["schemas"]["MetaData"];
    };
    Tree: {
      id?: number;
      name?: string;
      channels?: number[];
    };
    Tree_req: {
      id?: number;
      name?: string;
      channels?: number[];
    };
    CategoryNode: {
      id?: number;
      parent_id?: number;
      depth?: number;
      path?: number[];
      name?: string;
      is_visible?: boolean;
      children?: components["schemas"]["CategoryNode"][];
    };
    MetaPaginationObject: {
      pagination?: {
        /** @example 246 */
        total?: number;
        /** @example 5 */
        count?: number;
        /** @example 5 */
        per_page?: number;
        /** @example 1 */
        current_page?: number;
        /** @example 50 */
        total_pages?: number;
        links?: {
          /** @example ?limit=5&page=2 */
          next?: string;
          /** @example ?limit=5&page=1 */
          current?: string;
        };
      };
    };
    beta4DetailedErrors: {
      [key: string]: unknown;
    };
    /** @description Error payload for the BigCommerce API. */
    BaseError: {
      /** @description The HTTP status code. */
      status?: number;
      /** @description The error title describing the particular error. */
      title?: string;
      type?: string;
      instance?: string;
    };
    beta4ErrorResponse: components["schemas"]["BaseError"] & {
      errors?: components["schemas"]["beta4DetailedErrors"];
    };
    /** default_product_sort */
    default_product_sort: {
      /**
       * @description Determines how the products are sorted on category page load.
       *
       * @enum {string}
       */
      default_product_sort?: "use_store_settings" | "featured" | "newest" | "best_selling" | "alpha_asc" | "alpha_desc" | "avg_customer_review" | "price_asc" | "price_desc";
    };
    /** name */
    name: {
      /**
       * @description The name displayed for the category. Name is unique with respect to the category's siblings.
       * Required in a POST.
       * @example Bath
       */
      name?: string;
    };
    /** description */
    description: {
      /**
       * @description The product description, which can include HTML formatting.
       *
       * @example <p>We offer a wide variety of products perfect for relaxing</p>
       */
      description?: string;
    };
    /** views */
    views: {
      /**
       * @description Number of views the category has on the storefront.
       *
       * @example 1050
       */
      views?: number;
    };
    /** sort_order */
    sort_order: {
      /**
       * @description Priority this category will be given when included in the menu and category pages. The lower the number, the closer to the top of the results the category will be.
       *
       * @example 3
       */
      sort_order?: number;
    };
    /** page_title */
    page_title: {
      /**
       * @description Custom title for the category page. If not defined, the category name will be used as the meta title.
       *
       * @example Bath
       */
      page_title?: string;
    };
    /** search_keywords */
    search_keywords: {
      /** @description A comma-separated list of keywords that can be used to locate the category when searching the store. */
      search_keywords?: string;
    };
    /** meta_keywords */
    meta_keywords: {
      /** @description Custom meta keywords for the category page. If not defined, the store's default keywords will be used. Must post as an array like: ["awesome","sauce"]. */
      meta_keywords?: string[];
    };
    /** layout_file */
    layout_file: {
      /**
       * @description A valid layout file. (Please refer to [this article](https://support.bigcommerce.com/articles/Public/Creating-Custom-Template-Files/) on creating category files.) This field is writable only for stores with a Blueprint theme applied.
       *
       * @example category.html
       */
      layout_file?: string;
    };
    /** is_visible */
    is_visible: {
      /** @description Flag to determine whether the product should be displayed to customers browsing the store. If `true`, the category will be displayed. If `false`, the category will be hidden from view. */
      is_visible?: boolean;
    };
    /** image_url */
    image_url: {
      /**
       * @description Image URL used for this category on the storefront. Images can be uploaded via form file post to `/categories/{categoryId}/image`, or by providing a publicly accessible URL in this field.
       *
       * @example https://cdn8.bigcommerce.com/s-123456/product_images/d/fakeimage.png
       */
      image_url?: string;
    };
    /** meta_description */
    meta_description: {
      /** @description Custom meta description for the category page. If not defined, the store's default meta description will be used. */
      meta_description?: string;
    };
    /** id */
    id: {
      /**
       * @description Unique ID of the *Category*. Increments sequentially.
       * Read-Only.
       */
      id?: number;
    };
    /** parent_id */
    parent_id: {
      /**
       * @description The unique numeric ID of the category's parent. This field controls where the category sits in the tree of categories that organize the catalog.
       * Required in a POST if creating a child category.
       * @example 2
       */
      parent_id?: number;
    };
  };
  responses: never;
  parameters: {
    /** @description The [MIME type](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types) of the response body. */
    Accept: string;
    /** @description The [MIME type](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types) of the request body. */
    ContentType: string;
  };
  requestBodies: never;
  headers: never;
  pathItems: never;
}

export type external = Record<string, never>;

export interface operations {

  /**
   * Get All Categories
   * @description Returns a list of categories.
   *
   * To get a specific category in a tree, provide a category ID.
   */
  getAllCategories: {
    parameters: {
      query?: {
        "category_uuid:in"?: string;
        "category_uuid:not_in"?: string;
        "category_id:in"?: string;
        "category_id:not_in"?: string;
        "tree_id:in"?: string;
        "tree_id:not_in"?: string;
        "parent_id:in"?: string;
        "parent_id:not_in"?: string;
        name?: string;
        "name:like"?: string;
        page_title?: string;
        "page_title:like"?: string;
        keyword?: string;
        is_visible?: boolean;
        page?: number;
        limit?: number;
        include_fields?: string;
        exclude_fields?: string;
      };
      header: {
        Accept: components["parameters"]["Accept"];
      };
    };
    responses: {
      /** @description List of categories. */
      200: {
        content: {
          "application/json": {
            data?: components["schemas"]["Category"][];
            meta?: components["schemas"]["MetaPagination"];
          };
        };
      };
      /** @description Bad Request */
      400: {
        content: {
          "application/json": components["schemas"]["ErrorRequest"];
        };
      };
      /** @description Internal Server Error */
      500: {
        content: {
          "application/json": components["schemas"]["ErrorRequest"];
        };
      };
    };
  };
  /**
   * Update Categories
   * @description Updates existing categories.
   *
   *  To update a specific category in a tree, provide a category id.
   */
  updateCategories: {
    parameters: {
      header: {
        Accept: components["parameters"]["Accept"];
        "Content-Type": components["parameters"]["ContentType"];
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["UpdateCategories"];
      };
    };
    responses: {
      /** @description OK */
      200: never;
      /** @description No Content */
      204: {
        content: {
          "application/json": components["schemas"]["SuccessNoContentResponse"];
        };
      };
      /** @description Partial success */
      207: {
        content: {
          "application/json": components["schemas"]["PartialSuccessNoContentResponse"];
        };
      };
      /** @description Bad request */
      400: {
        content: {
          "application/json": components["schemas"]["ErrorRequest"];
        };
      };
      /** @description The Category was not valid. This is the result of missing required fields, or of invalid data. See the response for more details. */
      422: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
      /** @description Internal Server Error */
      500: {
        content: {
          "application/json": components["schemas"]["ErrorRequest"];
        };
      };
    };
  };
  /**
   * Create Categories
   * @description Creates new categories.
   *
   * Creating a category requires:
   *  - `name`
   *  - `url`
   *  - `tree_id` or `parent_id`
   */
  createCategories: {
    parameters: {
      header: {
        Accept: components["parameters"]["Accept"];
        "Content-Type": components["parameters"]["ContentType"];
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["CreateCategories"];
      };
    };
    responses: {
      /** @description Created */
      201: {
        content: {
          "application/json": components["schemas"]["SuccessResponse"];
        };
      };
      /** @description Multi-Status */
      207: {
        content: {
          "application/json": components["schemas"]["PartialSuccessResponse"];
        };
      };
      /** @description Bad Request */
      400: {
        content: {
          "application/json": components["schemas"]["ErrorRequest"];
        };
      };
      /** @description The Category was not valid. This is the result of missing required fields, or of invalid data. See the response for more details. */
      422: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
      /** @description Internal Server Error */
      500: {
        content: {
          "application/json": components["schemas"]["ErrorRequest"];
        };
      };
    };
  };
  /**
   * Delete Categories
   * @description Deletes categories.
   *
   * To delete a specific category in a tree, provide a category ID.
   */
  deleteTreeCategories: {
    parameters: {
      query?: {
        "category_uuid:in"?: string;
        "category_id:in"?: string;
        "tree_id:in"?: string;
        "parent_id:in"?: string;
      };
      header: {
        Accept: components["parameters"]["Accept"];
      };
    };
    responses: {
      /** @description Categories are deleted */
      204: {
        content: {
          "application/json": components["schemas"]["SuccessNoContentResponse"];
        };
      };
      /** @description Bad request */
      400: {
        content: {
          "application/json": components["schemas"]["ErrorRequest"];
        };
      };
      /** @description Server error */
      500: {
        content: {
          "application/json": components["schemas"]["ErrorRequest"];
        };
      };
    };
  };
  /**
   * Get All Category Trees
   * @description Returns a list of *Category Trees*.
   */
  GetCategoryTrees: {
    parameters: {
      query?: {
        "id:in"?: string;
        "channel_id:in"?: string;
      };
      header: {
        Accept: components["parameters"]["Accept"];
      };
    };
    responses: {
      /** @description List of category trees. */
      200: {
        content: {
          "application/json": {
            data?: components["schemas"]["Tree"][];
            meta?: components["schemas"]["MetaPaginationObject"];
          };
        };
      };
    };
  };
  /**
   * Upsert Category Trees
   * @description Upserts *Category Trees*.
   *
   * This single endpoint updates and creates category trees. If a tree object contains an ID, it is processed as an update operation using that ID. If you do not provide an ID, a new tree is created. The category tree `name` field is required to create trees, but is not required on the update.
   *
   * **Usage Notes**
   * * `channel_id` is required to create a *Category Tree*. You can assign one `channel_id` to one category tree.
   */
  UpsertCategoryTrees: {
    parameters: {
      header: {
        Accept: components["parameters"]["Accept"];
        "Content-Type": components["parameters"]["ContentType"];
      };
    };
    requestBody: {
      content: {
        /**
         * @example [
         *   {
         *     "id": 0,
         *     "name": "string",
         *     "channels": [
         *       0
         *     ]
         *   }
         * ]
         */
        "application/json": components["schemas"]["Tree_req"][];
      };
    };
    responses: {
      /** @description Created a category tree. */
      200: {
        content: {
          "application/json": {
            data?: components["schemas"]["Tree"][];
            meta?: components["schemas"]["metaEmpty_Full"];
          };
        };
      };
      /** @description The Channel was not valid. See the response for more details. */
      422: {
        content: {
          "application/json": components["schemas"]["beta4ErrorResponse"];
        };
      };
    };
  };
  /**
   * Delete Category Trees
   * @description Deletes *Category Trees*. A filter must be supplied with the endpoint.
   */
  DeleteCategoryTrees: {
    parameters: {
      query?: {
        "id:in"?: string;
      };
      header: {
        Accept: components["parameters"]["Accept"];
      };
    };
    responses: {
      /** @description Deleted */
      204: never;
    };
  };
  /**
   * Get a Category Tree
   * @description Returns a *Category Tree*.
   */
  GetCategoryTreeByTreeId: {
    parameters: {
      query?: {
        /** @description Max depth for a tree of categories. */
        depth?: number;
      };
      header: {
        Accept: components["parameters"]["Accept"];
      };
      path: {
        tree_id: string;
      };
    };
    responses: {
      /** @description Categories tree */
      200: {
        content: {
          "application/json": {
            data?: components["schemas"]["CategoryNode"][];
            meta?: components["schemas"]["metaEmpty_Full"];
          };
        };
      };
      /** @description The tree was not found. */
      404: {
        content: {
          "application/json": components["schemas"]["beta4ErrorResponse"];
        };
      };
    };
  };
}
