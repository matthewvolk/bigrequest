// @ts-nocheck
/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */


export interface paths {
  "/sites": {
    /**
     * Get Sites
     * @description Get sites linked to a [headless storefront](/docs/storefront/headless) sales channels.
     */
    get: operations["getSites"];
    /**
     * Create a Site
     * @description Create a site that links a [headless storefront](/docs/storefront/headless) to a sales [channel](/docs/rest-management/channels).
     */
    post: operations["createSite"];
    parameters: {
      header: {
        Accept: components["parameters"]["Accept"];
      };
    };
  };
  "/sites/{site_id}": {
    /**
     * Get a Site
     * @description Get a site with site ID `{site_id}`.
     */
    get: operations["getSite"];
    /**
     * Update a Site
     * @description Update a site with site ID `{site_id}`.
     */
    put: operations["updateSite"];
    /**
     * Delete a Site
     * @description Delete a site with site ID `{site_id}`.
     */
    delete: operations["deleteSite"];
    parameters: {
      header: {
        Accept: components["parameters"]["Accept"];
      };
      path: {
        site_id: string;
      };
    };
  };
  "/sites/{site_id}/routes": {
    /**
     * Get a Site’s Routes
     * @description Get a site’s routes.
     */
    get: operations["getSiteRoutes"];
    /**
     * Update a Site’s Routes
     * @description Upsert routes for site with ID `{site_id}`.
     *
     * ## Usage Notes
     * * `id` is required when updating an existing route.
     */
    put: operations["updateSiteRoutes"];
    /**
     * Create a Site Route
     * @description Create routes that tell BigCommerce how to link to pages on a [headless storefront](/docs/storefront/headless).
     *
     * ## Usage Notes
     * * For a list of supported route types, see [Route types](/docs/rest-management/sites#route-types).
     */
    post: operations["createSiteRoute"];
    parameters: {
      header: {
        Accept: components["parameters"]["Accept"];
      };
      path: {
        site_id: number;
      };
    };
  };
  "/sites/{site_id}/routes/{route_id}": {
    /**
     * Get a Site Route
     * @description Get a site’s route.
     */
    get: operations["getSiteRoute"];
    /**
     * Update a Site Route
     * @description Update a site’s route.
     */
    put: operations["updateSiteRoute"];
    /**
     * Delete a Site Route
     * @description Delete a site’s route.
     */
    delete: operations["deleteSiteRoute"];
    parameters: {
      header: {
        Accept: components["parameters"]["Accept"];
      };
      path: {
        site_id: string;
        route_id: string;
      };
    };
  };
  "/sites/{site_id}/certificate": {
    /**
     * Get a Site’s SSL/TLS Certificate Information
     * @description Obtain information about a site’s SSL/TLS certificate.
     */
    get: operations["getSiteCertificate"];
    /**
     * Upsert a Site’s SSL/TLS Certificate Information
     * @description - If a value for `url` is not supplied, the saved certificate is associated with the specified site’s `primary` URL.
     * - Use caution. Because this endpoint upserts, supplying an SSL certificate for a domain that already has a certificate connected overwrites the domain’s extant certificate.'
     */
    put: operations["upsertSiteCertificate"];
    parameters: {
      header: {
        Accept: components["parameters"]["Accept"];
      };
      path: {
        site_id: number;
      };
    };
  };
  "/sites/certificates": {
    /**
     * Get Site Certificates
     * @description Return all SSL certificates connected to domains within a store.
     */
    get: operations["getSitesCertificates"];
    parameters: {
      header: {
        Accept: components["parameters"]["Accept"];
      };
    };
  };
}

export type webhooks = Record<string, never>;

export interface components {
  schemas: {
    /**
     * metaCollection
     * @description Meta data relating to pagination.
     */
    _metaCollection: {
      pagination?: {
        /**
         * @description Total number of items returned.
         * @example 3
         */
        total?: number;
        /**
         * @description Number of items returned on per page.
         * @example 1
         */
        count?: number;
        /**
         * @description Number of items to be displayed per page.
         * @example 1
         */
        per_page?: number;
        /**
         * @description Current page number.
         * @example 2
         */
        current_page?: number;
        /**
         * @description Total number of pages.
         * @example 3
         */
        total_page?: number;
        links?: {
          /**
           * @description Query string appended to the resource to return to the previous page.
           * @example ?limit=1&page=1
           */
          previous?: string;
          /**
           * @description Query string appended to the resource to proceed to the next page.
           * @example ?limit=1&page=3
           */
          next?: string;
          /**
           * @description Query string appended to the resource to show the current page.
           * @example ?limit=1&page=2
           */
          current?: string;
        };
      };
    };
    /**
     * siteRoute_Full
     * @description Route object used in responses.
     */
    siteRoute_Full: {
      /** @description Unique ID for this route. Required when updating an existing route. */
      id?: number;
    } & components["schemas"]["siteRoute_Base"];
    /** put_Site */
    put_Site: {
      /**
       * @description The Fully Qualified URL (including host and scheme) where this site is hosted. All URLs generated for this site will be appended to this.
       * @example http://kittens.mybigcommerce.com/
       */
      url?: string;
    };
    _site: {
      id?: number;
      /**
       * @description The fully qualified URL (including host and scheme) where this site is hosted. All URLs generated for this site will be appended to this.
       * @example http://kittens.mybigcommerce.com/
       */
      url?: string;
      /** @description The channel to which this site is attached. Each site belongs to a single channel, and each channel can have either zero or more sites. */
      channel_id?: number;
      /**
       * @description The date-time that this site was created, formatted as an [RFC-3339](https://www.ietf.org/rfc/rfc3339.txt) string.
       * @example 2022-01-04T04:15:50.000Z
       */
      created_at?: string;
      /**
       * @description The date-time that this site was last updated, formatted as an [RFC-3339](https://www.ietf.org/rfc/rfc3339.txt) string.
       * @example 2022-01-04T04:15:50.000Z
       */
      updated_at?: string;
      /**
       * @description Indicates whether a site is using a private/dedicated SSL or a shared SSL.
       * @enum {string}
       */
      ssl_status?: "dedicated" | "shared";
      /** @description All URLs that belong to the site, including `primary`, `canonical`, and `checkout` URLs. */
      urls?: components["schemas"]["Url"][];
      /** @description Indicates whether the channel uses a custom checkout domain. When `false`, the checkout domain falls back to the default channel’s primary URL. */
      is_checkout_url_customized?: boolean;
    };
    /**
     * _metaEmpty
     * @description Empty meta object; may be used later.
     */
    _metaEmpty: Record<string, never>;
    /**
     * _pagination
     * @description Data about the response, including pagination and collection totals.
     */
    _pagination: {
      /** @description Total number of items in the result set. */
      total?: number;
      /** @description Total number of items in the collection response. */
      count?: number;
      /** @description The amount of items returned in the collection per page, controlled by the limit parameter. */
      per_page?: number;
      /** @description The page you are currently on within the collection. */
      current_page?: number;
      /** @description The total number of pages in the collection. */
      total_pages?: number;
      /** @description Pagination links for the previous and next parts of the whole collection. */
      links?: {
        /** @description Link to the previous page returned in the response. */
        previous?: string;
        /** @description Link to the current page returned in the response. */
        current?: string;
        /** @description Link to the next page returned in the response. */
        next?: string;
      };
    };
    /**
     * _errors
     * @description The keys and values in an errors object will vary depending on the error received.
     */
    _errors: Record<string, never>;
    EmptyResponse: {
      data?: Record<string, never>;
      meta?: Record<string, never>;
    };
    /** error_Full */
    error_Full: {
      /** @description The HTTP status code. */
      status?: number;
      /** @description The error title describing the particular error. */
      title?: string;
      type?: string;
    };
    /** errorDetailed_Full */
    errorDetailed_Full: {
      /** DetailedErrors */
      errors?: {
        [key: string]: unknown;
      };
    };
    /** post_Site */
    post_Site: {
      /**
       * @description The Fully Qualified URL (including host and scheme) where this site is hosted. All URLs generated for this site will be appended to this.
       * @example http://kittens.mybigcommerce.com/
       */
      url?: string;
      /** @description The channel this site is attached to. Each site belongs to a single channel, and each channel can have either zero or one sites. */
      channel_id?: number;
    };
    /** siteRoute_Base */
    siteRoute_Base: {
      /**
       * @description The type of resource being routed to; [supported types](/docs/rest-management/sites#route-types).
       * @enum {string}
       */
      type?: "product" | "brand" | "category" | "page" | "blog" | "home" | "cart" | "checkout" | "search" | "account" | "login" | "returns" | "static";
      /**
       * @description Depending on the resource type, this can be an ID (matching a specific item), or a "*" wildcard (matching all items of that type).
       *
       * For example, a route with a type: "product" and matching: "5" will be used for the product with the ID of 5.
       * @example 5
       */
      matching?: string;
      /**
       * @description The route template that will be used to generate the URL for the requested resource.
       *
       * Supports several tokens:
       * - `{id}` The **ID** of the requested item.
       * - `{slug}` The **slug** for the requested item (if available). Note: the `slug` value may contain `/` slash.
       * - `{language}` The **language** string that the client is using.
       * @example /my-amazing-product
       */
      route?: string;
    };
    /** siteRoutes_Route_Base */
    siteRoutes_Route_Base: {
      /**
       * @description The type of resource being routed to; [supported types](/docs/rest-management/sites#route-types).
       * @enum {string}
       */
      type: "product" | "brand" | "category" | "page" | "blog" | "home" | "cart" | "checkout" | "search" | "account" | "login" | "returns" | "static";
      /**
       * @description Depending on the resource type, this can be an ID (matching a specific item), or a "*" wildcard (matching all items of that type).
       *
       * For example, a route with a type: "product" and matching: "5" will be used for the product with the ID of 5.
       * @example 5
       */
      matching: string;
      /**
       * @description The route template that will be used to generate the URL for the requested resource.
       *
       * Supports several tokens:
       * - `{id}` The **ID** of the requested item.
       * - `{slug}` The **slug** for the requested item (if available). Note: the `slug` value may contain `/` slash.
       * - `{language}` The **language** string that the client is using.
       * @example /my-amazing-product
       */
      route: string;
    };
    /** @description BC Meta payload for collection-type responses. */
    IndexMeta: {
      pagination?: {
        /** @example 1 */
        total?: number;
        /** @example 1 */
        count?: number;
        /** @example 50 */
        per_page?: number;
        /** @example 1 */
        current_page?: number;
        /** @example 1 */
        total_pages?: number;
        links?: {
          /** @example ?page=1&limit=50 */
          previous?: string;
          /** @example ?page=1&limit=50 */
          current?: string;
          /** @example ?page=1&limit=50 */
          next?: string;
        };
      };
    };
    Url: {
      /** @description URL of site. */
      url?: string;
      /**
       * @description Specifies the URL type.
       * @enum {string}
       */
      type?: "primary" | "canonical" | "checkout";
      /**
       * Format: date-time
       * @description The date-time that this URL was created, formatted as an [RFC-3339](https://www.ietf.org/rfc/rfc3339.txt) string.
       * @example 2018-01-04T04:15:50.000Z
       */
      created_at?: string;
      /**
       * Format: date-time
       * @description The date-time that this URL was last updated, formatted as an [RFC-3339](https://www.ietf.org/rfc/rfc3339.txt) string.
       * @example 2018-01-04T04:15:50.000Z
       */
      updated_at?: string;
    };
    SiteCreate: {
      /**
       * @description The Fully Qualified URL (including host and scheme) where this site is hosted. All URLs generated for this site will be appended to this.
       * @example http://kittens.mybigcommerce.com/
       */
      url?: string;
      /** @description The channel this site is attached to. Each site belongs to a single channel, and each channel can have either zero or one sites. */
      channel_id?: number;
      certificate?: components["schemas"]["CertificateWrite"];
    };
    /** CertificateWrite */
    CertificateWrite: {
      /** @description The primary certificate, as a string. */
      certificate?: string;
      /** @description The private key, as a string. Is a "write-only" field, will never be returned after write. */
      private_key?: string;
      /** @description The intermediate certificate(s), as a string. */
      intermediate_certificates?: string;
    };
    /** CertificateResponse */
    CertificateResponse: {
      data?: {
        /** @enum {string} */
        status?: "shared" | "dedicated";
        installed_certificate?: components["schemas"]["InstalledCertificateDetail"];
      };
      meta?: components["schemas"]["MetaOpen"];
    };
    InstallCertificateData: {
      /**
       * @description URL for the site.
       * @example kittens.mybigcommerce.com
       */
      url?: string;
      certificate?: components["schemas"]["CertificateWrite"];
    };
    /**
     * CertificateInfo
     * @description Details about the installed certificate, including the raw certificate data, without the private key.
     */
    InstalledCertificateDetail: {
      /**
       * @description Common Name on the TLS certificate.
       * @example store.com
       */
      common_name?: string;
      /**
       * @description Subject Alternative Names for which the certificate is also valid.
       * @example [
       *   "store.com",
       *   "www.store.com"
       * ]
       */
      subject_alternative_names?: string[];
      /**
       * @description When does the validity period of this certificate begin? RFC 3339.
       * @example 2018-01-04T04:15:50.000Z
       */
      validity_not_before?: string;
      /**
       * @description When does the validity period of this certificate end? If this date is in the past, the certificate has expired. RFC 3339.
       * @example 2018-01-04T04:15:50.000Z
       */
      validity_not_after?: string;
      /** @description Signing algorithm used to sign the certificate. */
      signing_algorithm?: string;
      issuer?: string;
      /** @description The primary certificate, as a string. */
      certificate?: string;
      /** @description The intermediate certificate(s), as a string. */
      intermediate_certificates?: string;
    } | null;
    ErrorResponse: components["schemas"]["BaseError"] & {
      errors?: components["schemas"]["DetailedErrors"];
    };
    /** @description Error payload for the BigCommerce API. */
    BaseError: {
      /**
       * @description The HTTP status code.
       *
       * @example 404
       */
      status?: number;
      /** @description The error title describing the particular error. */
      title?: string;
      type?: string;
      instance?: string;
    };
    /** Detailed Errors */
    DetailedErrors: {
      [key: string]: unknown;
    };
    /** GetCertificatesResponse */
    GetCertificatesResponse: {
      data?: components["schemas"]["InstalledCertificateDetail"][];
      meta?: components["schemas"]["MetaOpen"];
    };
    /**
     * Response meta
     * @description Response metadata.
     */
    MetaOpen: {
      [key: string]: unknown;
    };
  };
  responses: {
    /** @description If something happens during the request that causes it to fail, a 502 response will be returned. A new request should be made; however, it could fail. */
    "502_GatewayError": {
      content: {
        "application/json": components["schemas"]["error_Full"];
      };
    };
    /** @description If this occurs, you should retry the request. Typically retrying the request several times will result in a successful request; However, if you are unable to successfully make a request, please check the BigCommerce system status [here](https://status.bigcommerce.com/). A service is likely down and the request will need to be made again when it is back up (in several hours usually). */
    "504_GatewayTimeout": {
      content: {
        "application/json": components["schemas"]["error_Full"];
      };
    };
    "403_Unauthorized": {
      content: {
        "application/json": components["schemas"]["error_Full"];
      };
    };
    /**
     * @description Malformed request syntax. Typically need to fix the JSON
     * request body to resend successfully.
     */
    "400_BadRequest": {
      content: {
        "application/json": components["schemas"]["error_Full"];
      };
    };
    /** @description Requested resource not founded. */
    "404_NotFound": {
      content: {
        "application/json": components["schemas"]["error_Full"];
      };
    };
    /** @description This occurs when missing or unacceptable data is passed for one or more fields. Please correct the values for the fields listed in the errors object. */
    "422_UnprocessableEntity": {
      content: {
        "application/json": components["schemas"]["errorDetailed_Full"];
      };
    };
    /** @description If this occurs, you should retry the request. If you are unable to successfully make a request, please check the BigCommerce system status [here](https://status.bigcommerce.com/). A service is likely down and the request will need to be made again when it is back up (in several hours usually). */
    "503_ServiceUnavailable": {
      content: {
        "application/json": components["schemas"]["error_Full"];
      };
    };
    response_Site: {
      content: {
        "application/json": {
          data?: components["schemas"]["_site"];
          meta?: components["schemas"]["_metaCollection"];
        };
      };
    };
    BulkErrorResponse: {
      content: {
        "application/json": {
          /** @description The HTTP status code. */
          status?: number;
          title?: string;
          errors?: components["schemas"]["_errors"];
          meta?: components["schemas"]["_metaEmpty"];
          type?: string;
        };
      };
    };
    ErrorResponse: {
      content: {
        "application/json": {
          /** @description General error message */
          title?: string;
          /** @description HTTP status code */
          status?: string;
          errors?: components["schemas"]["_errors"];
          type?: string;
        };
      };
    };
    site_RespCollection: {
      content: {
        "application/json": {
          data?: components["schemas"]["_site"][];
          meta?: components["schemas"]["_metaCollection"];
        };
      };
    };
    siteRoute_Resp: {
      content: {
        "application/json": {
          data?: components["schemas"]["siteRoute_Full"];
          meta?: components["schemas"]["MetaOpen"];
        };
      };
    };
  };
  parameters: {
    /** @description The [MIME type](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types) of the response body. */
    Accept: string;
    /** @description The [MIME type](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types) of the request body. */
    ContentType: string;
    SiteIdPathParam: number;
  };
  requestBodies: never;
  headers: never;
  pathItems: never;
}

export type $defs = Record<string, never>;

export type external = Record<string, never>;

export interface operations {

  /**
   * Get Sites
   * @description Get sites linked to a [headless storefront](/docs/storefront/headless) sales channels.
   */
  getSites: {
    parameters: {
      query?: {
        /** @description Specifies the page number in a limited (paginated) list of items. */
        page?: number;
        /** @description Controls the number of items per page in a limited (paginated) list of items. */
        limit?: number;
        /** @description Filters returned sites by channel ID. */
        "channel_id:in"?: number;
        /** @description Filters sites returned in the `data.urls` array by their URL type. */
        "url_type:in"?: string;
      };
      header: {
        Accept: components["parameters"]["Accept"];
      };
    };
    responses: {
      200: components["responses"]["site_RespCollection"];
    };
  };
  /**
   * Create a Site
   * @description Create a site that links a [headless storefront](/docs/storefront/headless) to a sales [channel](/docs/rest-management/channels).
   */
  createSite: {
    parameters: {
      header: {
        Accept: components["parameters"]["Accept"];
        "Content-Type": components["parameters"]["ContentType"];
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["post_Site"];
      };
    };
    responses: {
      201: components["responses"]["response_Site"];
      400: components["responses"]["400_BadRequest"];
      403: components["responses"]["403_Unauthorized"];
      404: components["responses"]["404_NotFound"];
      502: {
        content: never;
      };
      504: components["responses"]["504_GatewayTimeout"];
    };
  };
  /**
   * Get a Site
   * @description Get a site with site ID `{site_id}`.
   */
  getSite: {
    parameters: {
      header: {
        Accept: components["parameters"]["Accept"];
      };
      path: {
        site_id: string;
      };
    };
    responses: {
      200: components["responses"]["response_Site"];
    };
  };
  /**
   * Update a Site
   * @description Update a site with site ID `{site_id}`.
   */
  updateSite: {
    parameters: {
      header: {
        Accept: components["parameters"]["Accept"];
        "Content-Type": components["parameters"]["ContentType"];
      };
      path: {
        site_id: string;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["put_Site"];
      };
    };
    responses: {
      200: components["responses"]["response_Site"];
    };
  };
  /**
   * Delete a Site
   * @description Delete a site with site ID `{site_id}`.
   */
  deleteSite: {
    parameters: {
      header: {
        Accept: components["parameters"]["Accept"];
      };
      path: {
        site_id: string;
      };
    };
    responses: {
      204: {
        content: never;
      };
    };
  };
  /**
   * Get a Site’s Routes
   * @description Get a site’s routes.
   */
  getSiteRoutes: {
    parameters: {
      query?: {
        /** @description Filter routes by a specified resource type. */
        type?: string;
        /** @description Specifies the page number in a limited (paginated) list of items. */
        page?: number;
        /** @description Controls the number of items per page in a limited (paginated) list of items. */
        limit?: number;
      };
      header: {
        Accept: components["parameters"]["Accept"];
      };
      path: {
        site_id: number;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": {
            data?: components["schemas"]["siteRoute_Full"][];
            meta?: components["schemas"]["_metaCollection"];
          };
        };
      };
    };
  };
  /**
   * Update a Site’s Routes
   * @description Upsert routes for site with ID `{site_id}`.
   *
   * ## Usage Notes
   * * `id` is required when updating an existing route.
   */
  updateSiteRoutes: {
    parameters: {
      header: {
        Accept: components["parameters"]["Accept"];
        "Content-Type": components["parameters"]["ContentType"];
      };
      path: {
        site_id: number;
      };
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["siteRoute_Full"];
      };
    };
    responses: {
      200: {
        content: {
          "application/json": {
            data?: components["schemas"]["siteRoute_Full"][];
            meta?: components["schemas"]["_metaCollection"];
          };
        };
      };
      422: components["responses"]["BulkErrorResponse"];
    };
  };
  /**
   * Create a Site Route
   * @description Create routes that tell BigCommerce how to link to pages on a [headless storefront](/docs/storefront/headless).
   *
   * ## Usage Notes
   * * For a list of supported route types, see [Route types](/docs/rest-management/sites#route-types).
   */
  createSiteRoute: {
    parameters: {
      header: {
        Accept: components["parameters"]["Accept"];
        "Content-Type": components["parameters"]["ContentType"];
      };
      path: {
        site_id: number;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["siteRoute_Base"];
      };
    };
    responses: {
      201: components["responses"]["siteRoute_Resp"];
      422: components["responses"]["ErrorResponse"];
      502: components["responses"]["502_GatewayError"];
    };
  };
  /**
   * Get a Site Route
   * @description Get a site’s route.
   */
  getSiteRoute: {
    parameters: {
      header: {
        Accept: components["parameters"]["Accept"];
      };
      path: {
        site_id: string;
        route_id: string;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": {
            data?: components["schemas"]["siteRoute_Full"];
            meta?: components["schemas"]["MetaOpen"];
          };
        };
      };
    };
  };
  /**
   * Update a Site Route
   * @description Update a site’s route.
   */
  updateSiteRoute: {
    parameters: {
      header: {
        Accept: components["parameters"]["Accept"];
        "Content-Type": components["parameters"]["ContentType"];
      };
      path: {
        site_id: string;
        route_id: string;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["siteRoutes_Route_Base"];
      };
    };
    responses: {
      201: components["responses"]["siteRoute_Resp"];
    };
  };
  /**
   * Delete a Site Route
   * @description Delete a site’s route.
   */
  deleteSiteRoute: {
    parameters: {
      header: {
        Accept: components["parameters"]["Accept"];
      };
      path: {
        site_id: string;
        route_id: string;
      };
    };
    responses: {
      204: {
        content: never;
      };
    };
  };
  /**
   * Get a Site’s SSL/TLS Certificate Information
   * @description Obtain information about a site’s SSL/TLS certificate.
   */
  getSiteCertificate: {
    parameters: {
      header: {
        Accept: components["parameters"]["Accept"];
      };
      path: {
        site_id: number;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["CertificateResponse"];
        };
      };
    };
  };
  /**
   * Upsert a Site’s SSL/TLS Certificate Information
   * @description - If a value for `url` is not supplied, the saved certificate is associated with the specified site’s `primary` URL.
   * - Use caution. Because this endpoint upserts, supplying an SSL certificate for a domain that already has a certificate connected overwrites the domain’s extant certificate.'
   */
  upsertSiteCertificate: {
    parameters: {
      header: {
        Accept: components["parameters"]["Accept"];
        "Content-Type": components["parameters"]["ContentType"];
      };
      path: {
        site_id: number;
      };
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["InstallCertificateData"];
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["EmptyResponse"];
          "Example": unknown;
        };
      };
    };
  };
  /**
   * Get Site Certificates
   * @description Return all SSL certificates connected to domains within a store.
   */
  getSitesCertificates: {
    parameters: {
      query?: {
        /** @description Query certificates by one or more URLs */
        "urls:in"?: string;
      };
      header: {
        Accept: components["parameters"]["Accept"];
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["GetCertificatesResponse"];
        };
      };
    };
  };
}
